# [901. 滑雪](https://www.acwing.com/problem/content/903/)

[打卡](https://www.acwing.com/activity/content/problem/content/1013/1/)

> tag : 记忆化搜索，递归 dp

状态表示：f[i, j]从[i，j]开始滑的路径的集合。集合中路经过区域数的最大值。
状态计算：分为上下左右四类滑。路径上的值是越来越小的，所以不存在环。

```c++
#include <cstring>
#include <iostream>

using namespace std;

const int N = 310;

int n, m;
int h[N][N];
int f[N][N];

int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};

int  dp(int x, int y){
    int &v = f[x][y];
    if(v != -1) return v;

    v = 1;
    for(int i = 0; i < 4; i++){
        int nx = x + dx[i], ny = y + dy[i];
        if(nx >= 1 && nx <= n && ny >= 1 && ny <= m && h[nx][ny] < h[x][y])
            v = max(v, dp(nx, ny) + 1);
    }
    return v;
}

int main(){
    cin >> n >> m;

    for(int i = 1; i <= n; i ++){
        for(int j = 1; j <= m; j++){
            cin >> h[i][j];
        }
    }

    memset(f, -1, sizeof f);

    int res = 0;
    for(int i =1; i <= n ; i ++){
        for(int j = 1; j <= m; j++)
            res = max(res, dp(i, j));
    }

    cout << res;
    return 0;
}
```
