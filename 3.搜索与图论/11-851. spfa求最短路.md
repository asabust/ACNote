# [851. spfa 求最短路](https://www.acwing.com/activity/content/problem/content/920/1/)

spfa 是 ballman_ford 算法的宽搜优化。
不需要更新所有的 b。dist[a]如果不变的话，dist[b]一定不会变。

时间复杂度平均$O(E)$, 最坏$O(EV)$比如说网络图？

```c++
struct Edge{
    int a, b, w
}edge[N]

for n:
    for 所有边：a, b, w: //松弛操作，宽搜优化
        dist[b] = min(dist[b], dist[a] + w);

queue <- 1
while queue 不空
    t <- q.front;//取出对头
    更新t的所有出边
```

```c++
#include <cstring>
#include <iostream>
#include <queue>

using namespace std;

const int N = 100010;

int h[N], e[N], ne[N], idx;
int dist[N], w[N];
bool st[N];

int n, m;

void add(int a, int b, int c){
    w[idx] = c;
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}

int spfa(){
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    queue<int> q;
    q.push(1);
    st[1] = true;

    while(q.size()){
        int t = q.front();
        q.pop();

        st[t] = false;

        for(int i = h[t]; i != -1; i = ne[i]){
            int j = e[i];
            if(dist[j] > dist[t] + w[i]){
                dist[j] = dist[t] + w[i];
                if(!st[j]){
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    if(dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}

int main(){
    cin >> n >> m;

    memset(h, -1, sizeof h);

    while( m --){
        int a, b, c;
        cin >> a >> b >> c;
        add(a, b, c);
    }

    int res = spfa();
    if(res == -1){
        cout << "impossible" << endl;
    }
    else{
        cout << res << endl;
    }
    return 0;
}

```
