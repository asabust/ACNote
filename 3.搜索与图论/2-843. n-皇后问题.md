# [843. n-皇后问题](https://www.acwing.com/activity/content/problem/content/906/1/)

> tag : DFS

- 剪枝思想：边排边判断是否满足条件。提前判断，不满足条件则提前返回。
- 斜边的表示，用截距来表示：`y = -x + b`, `y = x + b`

1. 第一种搜索顺序：按行枚举 $O(n!)$

```c++
#include<iostream>

using namespace std;
const int N = 20;

int n;
char res[N][N];
bool col[N], dg[N], udg[N];

void dfs(int row){
    if(row == n ){
        for(int i = 0 ; i < n; i ++) puts(res[i]);
        puts("");
        return;
    }

    for(int i = 0; i < n; i ++){
        if(!col[i] && !dg[row + i] && !udg[i - row + n]){
            col[i] = dg[row + i] = udg[i - row + n] = true;
            res[row][i] = 'Q';

            dfs(row + 1);

            col[i] = dg[row + i] = udg[i - row + n] = false;
            res[row][i] = '.';
        }
    }
}

int main(){
    cin >> n;

    for(int i = 0; i < n; i ++ ){
        for( int j = 0; j < n; j++){
            res[i][j] = '.';
        }
    }
    dfs(0);
    return 0;
}
```

- 第二种搜索顺序：按格子枚举 0~$n^2$, 每次选择放或者不放皇后。$O(2^n)$

```c++
#include<iostream>

using namespace std;

const int N = 10;

int n;
char res[N][N];
bool row[N], col[N], dg[N], udg[N];

void dfs(int x, int y, int s){
    if(x == n) x = 0, y++;
    if(y == n){
        if(s == n){
            for(int i = 0; i < n ; i ++) puts(res[i]);
            puts("");
        }
        return;
    }

    dfs(x + 1, y, s);

    if(!col[x] && !row[y] && !dg[x + y] && !udg[y - x + n]){
        col[x] = row[y] = dg[x + y] = udg[y - x + n] = true;
        res[y][x] = 'Q';

        dfs(x + 1, y, s + 1);

        col[x] = row[y] = dg[x + y] = udg[y - x + n] = false;
        res[y][x] = '.';
    }
}

int main(){
    cin >> n;
    for(int i = 0; i < n; i ++ ){
        for(int j = 0 ; j < n ; j ++){
            res[i][j] = '.';
        }
    }
    dfs(0, 0, 0);

    return 0;
}
```

> 一道题目做两三个小时很正常的。
